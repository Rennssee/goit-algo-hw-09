# goit-algo-hw-09

Amount: 176
Greedy Algorithm Result: {50: 3, 25: 1, 1: 1}
Greedy Algorithm Time: 0.0
Dynamic Programming Result: {50: 3, 25: 1, 1: 1}
Dynamic Programming Time: 0.0

Amount: 533
Greedy Algorithm Result: {50: 10, 25: 1, 5: 1, 2: 1, 1: 1}
Greedy Algorithm Time: 0.0
Dynamic Programming Result: {50: 10, 25: 1, 5: 1, 2: 1, 1: 1}
Dynamic Programming Time: 0.0

Amount: 1954
Greedy Algorithm Result: {50: 39, 2: 2}
Greedy Algorithm Time: 0.0
Dynamic Programming Result: {50: 39, 2: 2}
Dynamic Programming Time: 0.0

Amount: 5734
Greedy Algorithm Result: {50: 114, 25: 1, 5: 1, 2: 2}
Greedy Algorithm Time: 0.0
Dynamic Programming Result: {50: 114, 25: 1, 5: 1, 2: 2}
Dynamic Programming Time: 0.0067713260650634766

Amount: 17634
Greedy Algorithm Result: {50: 352, 25: 1, 5: 1, 2: 2}
Greedy Algorithm Time: 0.0
Dynamic Programming Result: {50: 352, 25: 1, 5: 1, 2: 2}
Dynamic Programming Time: 0.015071868896484375

Як ми бачимо з отриманих результів результів Greedy Algorithm працює майже однаково швидко як з малини так і з великими сумами.
Dynamic Programming зі збільшенням числа видно його уповільнення.

Жадібний алгоритм:

Переваги:
Швидкий та простий для реалізації.
Інколи може дати оптимальний результат.
Недоліки:
Не завжди гарантує оптимальний результат для всіх випадків.
Вибір найбільш доступного елемента на кожному етапі може привести до ситуацій, коли в ітоговому розв'язку виявиться менше монет або неправильний набір монет для досягнення мінімальної кількості.
Алгоритм динамічного програмування:

Переваги:
Гарантовано знаходить оптимальний результат для будь-якої заданої суми.
Може бути ефективним для великих сум та різноманітних номіналів монет.
Недоліки:
Вимагає більше обчислювальних ресурсів та пам'яті, особливо для великих сум.
Складніший у реалізації.
Ситуаційні фактори:

Обсяг та розмір задачі: Динамічне програмування може бути більш вигідним для великих задач, де жадібний алгоритм може дати неоптимальний результат.
Набір монет: Якщо є обмежені можливості видачі решти через обмежений набір монет, жадібний алгоритм може бути досить ефективним.
Швидкість виконання: Якщо важлива швидкість виконання, особливо для менших задач, то жадібний алгоритм може бути більш привабливим.
